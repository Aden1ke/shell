hell.c:54:16: error: ‘command’ undeclared (first use in this function)
   54 |    handle_exit(command);
      |                ^~~~~~~
my_shell.c:54:16: note: each undeclared identifier is reported only once for each function it appears in
root@0c3e66815f03:/simple_shell# cat *.c                   #include "my_shell.h"
/**
 * handle_arguments - handle arguments
 * @line: string to break down
 * Return: void.
 */
void handle_arguments(char *line)
{
        char *command[1000], *token;
        int i = 0;

        token = strtok(line, " \t\n");
        while (token != NULL)
        {
                command[i++] = token;
                token = strtok(NULL, " \t\n");
        }
        command[i] = NULL;
        if (_strcmp(command[0], "exit") == 0)
        {
                exit(98);
        }
        if (execve(command[0], command, NULL) == -1)
        {
                perror("Error");
                exit(98);
        }
}
void handle_exit(char *command[])
{
        int exit_status = 0;
        if (command[1] != NULL)
        {
                exit_status = atoi(command[1]);
        }
                free(command);
                exit(exit_status);
}
/**
 * _strcmp - function that compares two strings.
 * @s1: pointer to the 1st string.
 * @s2: poniter to the 2nd string.
 * Return: Always 0.
 */
int _strcmp(char *s1, char *s2)
{
        int i;

        for (i = 0; s1[i] != '\0' && s1[i] == s2[i]; i++)
                ;
        return (s1[i] - s2[i]);
}
#include "my_shell.h"
/**
 * my_getline - my personal getline.
 * @buffer: string inputed.
 * @n: length of string.
 * @stream: file descriptor.
 * Return: 0n success 1.
 */
ssize_t my_getline(char **buffer, size_t *n, FILE *stream)
{
        initialize_buffer(buffer, n);
        return (read_from_buffer(buffer, n, stream));
}
/**
 * initialize_buffer - my personal getline.
 * @buffer: string inputed.
 * @n: length of string.
 * Return: 0n success 1.
 */
void initialize_buffer(char **buffer, size_t *n)
{
        if (buffer == NULL || n == NULL)
                return;

        if (*buffer == NULL || *n == 0)
        {
                *n = BUFFER_SIZE;
                *buffer = malloc(*n * sizeof(char));
                if (*buffer == NULL)
                {
                        exit(EXIT_FAILURE);
                }
        }
}
/**
 * read_from_buffer - my personal getline.
 * @buffer: string inputed.
 * @n: length of string.
 * @stream: file descriptor.
 * Return: 0n success 1.
 */
ssize_t read_from_buffer(char **buffer, size_t *n, FILE *stream)
{
        static char read_buffer[BUFFER_SIZE];
        static size_t buffer_position;
        static ssize_t bytes_in_buffer;
        size_t i = 0;
        char result;
        int newline_found = 0;

        while (!newline_found)
        {
                if ((ssize_t)buffer_position >= bytes_in_buffer)
                {
                        bytes_in_buffer = read(fileno(stream), read_buffer, BUFFER_SIZE);
                        buffer_position = 0;
                        if (bytes_in_buffer <= 0)
                                break;
                }
                result = read_buffer[buffer_position++];
                (*buffer)[i++] = result;
                if (result == '\n')
                        newline_found = 1;
                if (i >= *n - 1)
                {
                        *n *= 2;
                        *buffer = realloc(*buffer, *n * sizeof(char));
                        if (*buffer == NULL)
                        {
                                exit(EXIT_FAILURE);
                        }
                }
        }

        if (i == 0 && bytes_in_buffer <= 0)
        {
                return (-1);
        }

        (*buffer)[i] = '\0';
        return ((ssize_t)i);
}
#include "my_shell.h"
/**
 * main - Simple shell program that runs shell commands
 * similar to the bash script
 * @argc: number count
 * @argv: argument vector.
 * Return: 0.
 */
int main(int argc, char *argv[])
{
        bool pipe = false;
        char *start = "$ ", *buf = NULL;
        ssize_t data;
        size_t size = 0;
        pid_t my_pid;
        int p_stat;

        argc = argc;
        argv = argv;
        while (1 && !pipe)
        {
                if (isatty(STDIN_FILENO) == 0)
                        pipe = true;

                write(STDOUT_FILENO, start, 2);

                data = my_getline(&buf, &size, stdin);
                if (data == -1)
                {
                        perror("getline error");
                        free(buf);
                }

                if (buf[data - 1] == '\n')
                        buf[data - 1] = '\0';

                my_pid = fork();
                if (my_pid < 0)
                {
                        perror("fork error");
                        exit(EXIT_FAILURE);
                }
                if (my_pid == 0)
                {
                        handle_arguments(buf);
                }

                waitpid(my_pid, &p_stat, 0);
                if (p_stat != 0)
                {
                        exit(EXIT_FAILURE);
                }
                if (_strcmp(buf, "exit") == 0)
                        handle_exit(command);
        }
        free(buf);
        return (0);
}
